{"version":3,"sources":["../../../src/datasource/templateQuery/queryParser.js"],"names":["PRIVATE_PROPERTIES","type","Symbol","value","token","residuals","NULL_TOKEN_TYPE","Token","concat","filter","isNull","getToken","ReadResult","withNullTokens","aggregatedValue","reduce","aggregation","subToken","push","result","mergedValues","getNullToken","tokenType","tokenValues","tokenRegExpResult","length","getReadResult","GenericTokenReaders","pattern","input","regExpResult","match","RegExp","getReadResultFromTokenRegExp","selectorName","selectorPattern","readToken","tokenReader","currentResult","mergeResult","tokenReadersIterator","readedTokens","iterationOK","tokenReaders","readTokens","anonymousCallback","every","some","iteratorResult","forEach","reader","index","array","getNullReadResult","QueryTokenReaders","replaceHashedChars","string","replace","parameterCharPattern","parameterPattern","selectorReadResult","readSelectorToken","parameterReadResult","parameterValue","readResult","readTokenSequence","readDot","readSelectorWithStringParameter","readerInput","aggregateSubTokensValues","readDotSelectorWithStringParameter","readRepetitiveToken","readFolder","QueryParser","query","atoms","readNodes","readMonitoringPacks","readNetworkAtlas","readRepetitiveFolder","readView","readName","readDeviceType","readNullToken","queryGrammar","networkFoldersView","foldersView","nothing","readTokensIfOccur","networkMap","monitoringPack","networkMapOrMonitoringPack","mapOrMonitoringPack","readFirstOccurredToken","getReadResultWithToken","parameters","nodes","parametersResult","removeNulls"],"mappings":"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","file":"queryParser.js","sourcesContent":["/**\n * @license\n * Copyright AdRem Software. All Rights Reserved.\n *\n * Use of this source code is governed by an Apache License, Version 2.0 that can be\n * found in the LICENSE file.\n */\n\nconst\n  PRIVATE_PROPERTIES = {\n    type: Symbol('type'),\n    value: Symbol('value'),\n    token: Symbol('token'),\n    residuals: Symbol('residuals')\n  },\n  NULL_TOKEN_TYPE = 'NULL';\n\nclass Token {\n\n  constructor(type, value) {\n    this[PRIVATE_PROPERTIES.type] = type;\n    this[PRIVATE_PROPERTIES.value] = value;\n  }\n\n  get type() {\n    return this[PRIVATE_PROPERTIES.type];\n  }\n\n  get value() {\n    return this[PRIVATE_PROPERTIES.value];\n  }\n\n  isNull() {\n    return (this.type === NULL_TOKEN_TYPE);\n  }\n\n  removeNulls() {\n    this[PRIVATE_PROPERTIES.value] = [].concat(this.value).filter(token => (token != null) && (!token.isNull()));\n  }\n\n  static getToken(type, value) {\n    return new Token(type, value);\n  }\n\n  static getNullToken() {\n    return Token.getToken(NULL_TOKEN_TYPE, null);\n  }\n\n}\n\nclass ReadResult {\n\n  constructor(token, residuals) {\n    this[PRIVATE_PROPERTIES.token] = token;\n    this[PRIVATE_PROPERTIES.residuals] = residuals;\n  }\n\n  get token() {\n    return this[PRIVATE_PROPERTIES.token];\n  }\n\n  get residuals() {\n    return this[PRIVATE_PROPERTIES.residuals];\n  }\n\n  aggregateSubTokensValues(withNullTokens = false) {\n    let aggregatedValue;\n\n    if (this.token != null) {\n      aggregatedValue = ([].concat(this.token.value)).reduce((aggregation, subToken) => {\n        if (withNullTokens || (!subToken.isNull())) {\n          aggregation.push(...([].concat(subToken.value)));\n        }\n        return aggregation;\n      }, []);\n      this[PRIVATE_PROPERTIES.token] = Token.getToken(this.token.type, aggregatedValue);\n    }\n  }\n\n  mergeResult(result, residuals) {\n    let mergedValues;\n    if ((this.token != null) && (result != null) && (result.token != null)) {\n      mergedValues = [].concat(this.token.value).concat(result.token.value);\n      this[PRIVATE_PROPERTIES.token] = Token.getToken(this.token.type, mergedValues);\n      this[PRIVATE_PROPERTIES.residuals] = (residuals != null) ? residuals : result.residuals;\n    }\n  }\n\n  static getReadResultWithToken(token, residuals) {\n    return new ReadResult(token, residuals);\n  }\n\n  static getNullReadResult(residuals) {\n    return new ReadResult(Token.getNullToken(), residuals);\n  }\n\n  static getReadResult(tokenType, tokenValues, residuals) {\n    return new ReadResult(Token.getToken(tokenType, tokenValues), residuals);\n  }\n\n  static getReadResultFromTokenRegExp(tokenType, tokenRegExpResult) {\n    if ((tokenRegExpResult != null) && (tokenRegExpResult.length >= 3)) {\n      return this.getReadResult(tokenType, tokenRegExpResult[1], tokenRegExpResult[2]);\n    }\n    return null;\n  }\n\n}\n\nclass GenericTokenReaders {\n\n  static readToken(tokenType, pattern, input) {\n    const regExpResult = (input || '').match(new RegExp(`^${pattern}(.*)$`, 'i'));\n    return ReadResult.getReadResultFromTokenRegExp(tokenType, regExpResult);\n  }\n\n  static readSelectorToken(tokenType, selectorName, input) {\n    const\n      selectorParametersPattern = '(?:(?:\\\\\\\\\\\\(|\\\\\\\\\\\\))|[^()])+',\n      selectorPattern = `(?:${selectorName})\\\\((${selectorParametersPattern})\\\\)`;\n    return this.readToken(tokenType, selectorPattern, input);\n  }\n\n  static readRepetitiveToken(tokenType, tokenReader, input) {\n    let currentResult = tokenReader(input);\n    const result = currentResult;\n\n    while (currentResult != null) {\n      currentResult = tokenReader(currentResult.residuals);\n      result.mergeResult(currentResult);\n    }\n\n    return (result != null) ? ReadResult.getReadResult(tokenType, result.token.value, result.residuals) : null;\n  }\n\n  static readTokens(tokenType, tokenReadersIterator, input) {\n    const readedTokens = [];\n    let\n      iterationOK,\n      residuals = input;\n\n    iterationOK = tokenReadersIterator((tokenReader) => {       // eslint-disable-line prefer-const\n      const result = tokenReader(residuals);\n      if (result != null) {\n        readedTokens.push(result.token);\n        residuals = result.residuals;\n        return true;\n      }\n      return false;\n    });\n\n    return (iterationOK) ? ReadResult.getReadResult(tokenType, readedTokens, residuals) : null;\n  }\n\n  static readTokenSequence(tokenType, tokenReaders, input) {\n\n    function sequenceIterator(anonymousCallback) {\n      return tokenReaders.every(anonymousCallback);\n    }\n\n    return this.readTokens(tokenType, sequenceIterator, input);\n  }\n\n  static readFirstOccurredToken(tokenType, tokenReaders, input) {\n\n    function firstOccurredIterator(anonymousCallback) {\n      return tokenReaders.some(anonymousCallback);\n    }\n\n    return this.readTokens(tokenType, firstOccurredIterator, input);\n  }\n\n  static readTokensIfOccur(tokenType, tokenReaders, input) {\n\n    function ifOccurIterator(anonymousCallback) {\n      let iteratorResult = false;\n\n      tokenReaders.forEach((reader, index, array) => {\n        const result = anonymousCallback(reader, index, array);\n        if (result) {\n          iteratorResult = true;\n        }\n      });\n\n      return iteratorResult;\n    }\n\n    return this.readTokens(tokenType, ifOccurIterator, input);\n  }\n\n  static readNullToken(input) {\n    return ReadResult.getNullReadResult(input);\n  }\n\n}\n\nclass QueryTokenReaders {\n\n  static readNodes(input) {\n    return GenericTokenReaders.readToken('nodes', 'nodes()', input);\n  }\n\n  static readMonitoringPacks(input) {\n    return GenericTokenReaders.readToken('monitoringPacks', '\\\\.monitoringPacks()', input);\n  }\n\n  static readSelectorWithStringParameter(tokenType, selectorName, input) {\n    const\n      parameterCharPattern = '(?:[\\\\w~`!@#$%^&*_+-=\\\\[\\\\]{};\\':<>,\\\\.\\\\?\\\\/|]|\\\\\\\\\"|\\\\\\\\\\\\(|\\\\\\\\\\\\)|\\\\\\\\)',\n      parameterPattern = `\"(\\\\s*${parameterCharPattern}+(?:[\\\\s]${parameterCharPattern}+)*\\\\s*)\"`,\n      selectorReadResult = GenericTokenReaders.readSelectorToken('', selectorName, input);\n    let\n      parameterReadResult,\n      parameterValue;\n\n    function replaceHashedChars(string) {\n      let result;\n\n      result = (string || '').replace(/\\\\\\(/g, '(');\n      result = result.replace(/\\\\\\)/g, ')');\n      result = result.replace(/\\\\\"/g, '\"');\n      return result;\n    }\n\n    if (selectorReadResult != null) {\n      parameterReadResult = GenericTokenReaders.readToken('', parameterPattern, selectorReadResult.token.value);\n      parameterValue = replaceHashedChars(parameterReadResult.token.value);\n    }\n\n    if ((selectorReadResult != null) && (parameterReadResult != null)) {\n      return ReadResult.getReadResult(tokenType, parameterValue, selectorReadResult.residuals);\n    }\n\n    return null;\n  }\n\n  static readDot(input) {\n    return GenericTokenReaders.readToken('dot', '(\\\\.)', input);\n  }\n\n  static readDotSelectorWithStringParameter(tokenType, selectorName, input) {\n    const\n      selectorReader = (readerInput => this.readSelectorWithStringParameter('', selectorName, readerInput)),\n      readResult = GenericTokenReaders.readTokenSequence('', [this.readDot, selectorReader], input);\n\n    if (readResult != null) {\n      readResult.aggregateSubTokensValues();\n      return ReadResult.getReadResult(tokenType, readResult.token.value[1], readResult.residuals);\n    }\n    return null;\n  }\n\n  static readNetworkAtlas(input) {\n    return QueryTokenReaders.readDotSelectorWithStringParameter('networkAtlas', 'networkAtlas', input);\n  }\n\n  static readFolder(input) {\n    return QueryTokenReaders.readDotSelectorWithStringParameter('folder', 'folder', input);\n  }\n\n  static readRepetitiveFolder(input) {\n    const result = GenericTokenReaders.readRepetitiveToken('folders', QueryTokenReaders.readFolder, input);\n    return result;\n  }\n\n  static readView(input) {\n    return QueryTokenReaders.readDotSelectorWithStringParameter('view', 'view', input);\n  }\n\n  static readName(input) {\n    return QueryTokenReaders.readDotSelectorWithStringParameter('name', 'name', input);\n  }\n\n  static readDeviceType(input) {\n    const deviceTypes = 'windows\\\\.server|windows\\\\.workstation|windows|linux|bsd|macos|solaris|esx|xenserver' +\n                        '|unix|novell|ibm';\n    return GenericTokenReaders.readToken('deviceType', `\\\\.(${deviceTypes})`, input);\n  }\n\n}\n\nclass QueryParser {\n\n  /*\n    Query grammar:\n      <networkFolderView> ::= ['.repetitiveFolder'][.view]'nothing'\n      <networkMap> ::= '.networkAtlas'['networkFolderView']\n      <monitoringPack> ::= '.monitoringPacks''.repetitiveFolder''.name'\n      <networkMapOrMonitoringPack> ::= <networkMap>|<monitoringPack>\n      <query> ::= 'nodes'[<networkMapOrMonitoringPack>]['.deviceType']\n  */\n\n  static parse(query) {\n    const\n      atoms = {\n        'nodes': QueryTokenReaders.readNodes,                         // eslint-disable-line quote-props\n        '.monitoringPacks': QueryTokenReaders.readMonitoringPacks,\n        '.networkAtlas': QueryTokenReaders.readNetworkAtlas,\n        '.repetitiveFolder': QueryTokenReaders.readRepetitiveFolder,\n        '.view': QueryTokenReaders.readView,\n        '.name': QueryTokenReaders.readName,\n        '.deviceType': QueryTokenReaders.readDeviceType,\n        'nothing': GenericTokenReaders.readNullToken                  // eslint-disable-line quote-props\n      },\n      queryGrammar = {\n\n        networkFoldersView: (input) => {\n          const\n            foldersView = [atoms['.repetitiveFolder'], atoms['.view'], atoms.nothing],\n            result = GenericTokenReaders.readTokensIfOccur('networkFoldersView', foldersView, input);\n          if (result != null) {\n            result.aggregateSubTokensValues();\n          }\n          return result;\n        },\n\n        networkMap: (input) => {\n          const\n            networkMap = [atoms['.networkAtlas'], queryGrammar.networkFoldersView],\n            result = GenericTokenReaders.readTokenSequence('networkMap', networkMap, input);\n\n          if (result != null) {\n            result.aggregateSubTokensValues();\n          }\n          return result;\n        },\n\n        monitoringPack: (input) => {\n          const\n            monitoringPack = [atoms['.monitoringPacks'], atoms['.repetitiveFolder'], atoms['.name']],\n            result = GenericTokenReaders.readTokenSequence('monitoringPack', monitoringPack, input);\n\n          if (result != null) {\n            result.aggregateSubTokensValues();\n          }\n          return result;\n        },\n\n        networkMapOrMonitoringPack: (input) => {\n          const\n            mapOrMonitoringPack = [queryGrammar.networkMap, queryGrammar.monitoringPack, atoms.nothing],\n            result = GenericTokenReaders.readFirstOccurredToken('', mapOrMonitoringPack, input);\n          if (result != null) {\n            return ReadResult.getReadResultWithToken(result.token.value[0], result.residuals);\n          }\n          return null;\n        },\n\n        query: (input) => {\n          const parameters = [queryGrammar.networkMapOrMonitoringPack, atoms['.deviceType'], atoms.nothing];\n          let\n            result = atoms.nodes(input),\n            parametersResult;\n\n          if (result != null) {\n            result = ReadResult.getReadResult('query', [result.token], result.residuals);\n            parametersResult = GenericTokenReaders.readTokensIfOccur('', parameters, result.residuals);\n            result.mergeResult(parametersResult);\n            result.token.removeNulls();\n          }\n          return result;\n        }\n\n      };\n\n    return queryGrammar.query(query);\n  }\n\n}\n\nexport {\n  QueryParser\n};\n"]}