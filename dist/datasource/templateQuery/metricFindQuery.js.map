{"version":3,"sources":["../../../src/datasource/templateQuery/metricFindQuery.js"],"names":["QueryParser","NetCrunchMetricFindQuery","datasource","query","parsingResult","parseQuery","completeParsed","Promise","all","nodes","atlas","then","result","allNodes","processingResult","processQuery","tokens","createQueryResult","success","resolve","parse","unparsedQuery","residuals","token","value","getProcessingResult","nodeList","getNodeIdsForSubMap","map","subMapNamesSequence","subMap","length","push","allNodesId","getChildMapByDisplayName","shift","filterNodesByIds","nodeIds","nodesMap","Map","forEach","set","node","id","nodeId","has","get","filterNodesBySubMap","inputNodeList","concat","filteredNodes","tokenProcessors","deviceType","filter","checkDeviceType","networkMap","networkAtlasRoot","monitoringPack","parameter","monitoringPacks","currentToken","processingSuccessful","nodesForProcessing","type","ipAddress","address","text","name"],"mappings":"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","file":"metricFindQuery.js","sourcesContent":["/**\r\n * @license\r\n * Copyright AdRem Software. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an Apache License, Version 2.0 that can be\r\n * found in the LICENSE file.\r\n */\r\n\r\nimport { QueryParser } from './queryParser';\r\n\r\nclass NetCrunchMetricFindQuery {\r\n\r\n  constructor(datasource, query) {\r\n    this.datasource = datasource;\r\n    this.query = query;\r\n  }\r\n\r\n  process() {\r\n    const parsingResult = NetCrunchMetricFindQuery.parseQuery(this.query);\r\n\r\n    if (parsingResult.completeParsed) {\r\n      return Promise.all([this.datasource.nodes(), this.datasource.atlas()])\r\n        .then((result) => {\r\n          const\r\n            atlas = result[1],\r\n            allNodes = result[0].all,\r\n            processingResult = NetCrunchMetricFindQuery.processQuery(parsingResult.tokens, atlas, allNodes);\r\n\r\n          return NetCrunchMetricFindQuery.createQueryResult((processingResult.success) ? processingResult.nodes : []);\r\n        });\r\n    }\r\n\r\n    return Promise.resolve(NetCrunchMetricFindQuery.createQueryResult([]));\r\n  }\r\n\r\n  static parseQuery(query) {\r\n    const\r\n      parsingResult = QueryParser.parse(query),\r\n      result = {\r\n        completeParsed: false,\r\n        unparsedQuery: '',\r\n        tokens: []\r\n      };\r\n\r\n    if (parsingResult != null) {\r\n      result.completeParsed = (parsingResult.residuals === '');\r\n      result.unparsedQuery = parsingResult.residuals;\r\n      result.tokens = parsingResult.token.value;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  static processQuery(tokens, atlas, nodes) {\r\n\r\n    function getProcessingResult(success, nodeList) {\r\n      return {\r\n        success,\r\n        nodes: nodeList\r\n      };\r\n    }\r\n\r\n    function getNodeIdsForSubMap(map, subMapNamesSequence) {\r\n      const result = [];\r\n      let subMap;\r\n\r\n      if (subMapNamesSequence.length === 0) {\r\n        result.push(...map.allNodesId);\r\n        result.success = true;\r\n        return result;\r\n      }\r\n\r\n\r\n      subMap = map.getChildMapByDisplayName(subMapNamesSequence.shift());         // eslint-disable-line prefer-const\r\n      if (subMap != null) {\r\n        return getNodeIdsForSubMap(subMap, subMapNamesSequence);\r\n      }\r\n\r\n      result.success = false;\r\n      return result;\r\n    }\r\n\r\n    function filterNodesByIds(nodeList, nodeIds) {\r\n      const\r\n        nodesMap = new Map(),\r\n        result = [];\r\n\r\n      nodeList.forEach(node => nodesMap.set(node.id, node));\r\n      nodeIds.forEach((nodeId) => {\r\n        if (nodesMap.has(nodeId)) {\r\n          result.push(nodesMap.get(nodeId));\r\n        }\r\n      });\r\n\r\n      return result;\r\n    }\r\n\r\n    function filterNodesBySubMap(inputNodeList, map, subMapNamesSequence) {\r\n      const nodeIds = getNodeIdsForSubMap(map, [].concat(subMapNamesSequence));\r\n      let filteredNodes = [];\r\n\r\n      if (nodeIds.success) {\r\n        filteredNodes = filterNodesByIds(inputNodeList, nodeIds);\r\n      }\r\n\r\n      return getProcessingResult(\r\n        nodeIds.success,\r\n        filteredNodes\r\n      );\r\n    }\r\n\r\n    function createNodesTokenProcessor(nodeList) {\r\n      return () => getProcessingResult(true, nodeList);\r\n    }\r\n\r\n    function deviceTypeTokenProcessor(deviceType, nodeList) {\r\n      return getProcessingResult(\r\n        true,\r\n        nodeList.filter(node => node.checkDeviceType(deviceType))\r\n      );\r\n    }\r\n\r\n    function networkMapTokenProcessor(subMapNamesSequence, nodeList) {\r\n      return filterNodesBySubMap(nodeList, atlas.networkAtlasRoot, subMapNamesSequence);\r\n    }\r\n\r\n    function monitoringPackTokenProcessor(parameter, nodeList) {\r\n      parameter.shift();\r\n      return filterNodesBySubMap(nodeList, atlas.monitoringPacks, parameter);\r\n    }\r\n\r\n    const\r\n      tokenProcessors = {\r\n        nodes: createNodesTokenProcessor(nodes),\r\n        deviceType: deviceTypeTokenProcessor,\r\n        networkMap: networkMapTokenProcessor,\r\n        monitoringPack: monitoringPackTokenProcessor\r\n      };\r\n    let\r\n      currentToken,\r\n      processingSuccessful = true,\r\n      processingResult,\r\n      nodesForProcessing = [];\r\n\r\n    while (processingSuccessful && (tokens.length > 0)) {\r\n      currentToken = tokens.shift();\r\n      processingResult = tokenProcessors[currentToken.type](currentToken.value, nodesForProcessing);\r\n      processingSuccessful = processingResult.success;\r\n\r\n      if (processingSuccessful) {\r\n        nodesForProcessing = processingResult.nodes;\r\n      }\r\n    }\r\n\r\n    return {\r\n      success: processingSuccessful,\r\n      nodes: nodesForProcessing\r\n    };\r\n  }\r\n\r\n  static createQueryResult(nodes) {\r\n    return (nodes || []).map((node) => {\r\n      const ipAddress = (node.address != null) ? `(${node.address})` : '';\r\n      return {\r\n        text: `${node.name} ${ipAddress}`,\r\n        value: node.id\r\n      };\r\n    });\r\n  }\r\n\r\n}\r\n\r\nexport {\r\n  NetCrunchMetricFindQuery\r\n};\r\n"]}