{"version":3,"sources":["../../../src/datasource/templateQuery/metricFindQuery.js"],"names":["QueryParser","NetCrunchDefaultEnglishMonitoringPacks","NetCrunchMetricFindQuery","datasource","query","parsingResult","parseQuery","completeParsed","Promise","all","nodes","atlas","then","result","allNodes","processingResult","processQuery","tokens","createQueryResult","success","resolve","parse","unparsedQuery","residuals","token","value","getProcessingResult","nodeList","getNodeIdsForSubMap","map","subMapNamesSequence","subMap","length","push","allNodesId","getChildMapByDisplayName","shift","filterNodesByIds","nodeIds","nodesMap","Map","forEach","set","node","id","nodeId","has","get","filterNodesBySubMap","inputNodeList","concat","filteredNodes","filterNodesByMap","mapId","atlasMaps","tokenProcessors","deviceType","filter","checkDeviceType","networkMap","networkAtlasRoot","monitoringPack","parameter","monitoringPackPath","nodesAtlasMonitoringPack","monitoringPacks","monitoringPackId","getMonitoringPackId","currentToken","processingSuccessful","nodesForProcessing","type","ipAddress","address","text","name"],"mappings":"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","file":"metricFindQuery.js","sourcesContent":["/**\r\n * @license\r\n * Copyright AdRem Software. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an Apache License, Version 2.0 that can be\r\n * found in the LICENSE file.\r\n */\r\n\r\nimport { QueryParser } from './queryParser';\r\nimport { NetCrunchDefaultEnglishMonitoringPacks } from './defaultEnglishMonitoringPacks';\r\n\r\nclass NetCrunchMetricFindQuery {\r\n\r\n  constructor(datasource, query) {\r\n    this.datasource = datasource;\r\n    this.query = query;\r\n  }\r\n\r\n  process() {\r\n    const parsingResult = NetCrunchMetricFindQuery.parseQuery(this.query);\r\n\r\n    if (parsingResult.completeParsed) {\r\n      return Promise.all([this.datasource.nodes(), this.datasource.atlas()])\r\n        .then((result) => {\r\n          const\r\n            atlas = result[1],\r\n            allNodes = result[0].all,\r\n            processingResult = NetCrunchMetricFindQuery.processQuery(parsingResult.tokens, atlas, allNodes);\r\n\r\n          return NetCrunchMetricFindQuery.createQueryResult((processingResult.success) ? processingResult.nodes : []);\r\n        });\r\n    }\r\n\r\n    return Promise.resolve(NetCrunchMetricFindQuery.createQueryResult([]));\r\n  }\r\n\r\n  static parseQuery(query) {\r\n    const\r\n      parsingResult = QueryParser.parse(query),\r\n      result = {\r\n        completeParsed: false,\r\n        unparsedQuery: '',\r\n        tokens: []\r\n      };\r\n\r\n    if (parsingResult != null) {\r\n      result.completeParsed = (parsingResult.residuals === '');\r\n      result.unparsedQuery = parsingResult.residuals;\r\n      result.tokens = parsingResult.token.value;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  static processQuery(tokens, atlas, nodes) {\r\n\r\n    function getProcessingResult(success, nodeList) {\r\n      return {\r\n        success,\r\n        nodes: nodeList\r\n      };\r\n    }\r\n\r\n    function getNodeIdsForSubMap(map, subMapNamesSequence) {\r\n      const result = [];\r\n      let subMap;\r\n\r\n      if (map != null) {\r\n        if (subMapNamesSequence.length === 0) {\r\n          result.push(...map.allNodesId);\r\n          result.success = true;\r\n          return result;\r\n        }\r\n\r\n        subMap = map.getChildMapByDisplayName(subMapNamesSequence.shift());     // eslint-disable-line prefer-const\r\n        if (subMap != null) {\r\n          return getNodeIdsForSubMap(subMap, subMapNamesSequence);\r\n        }\r\n      }\r\n\r\n      result.success = false;\r\n      return result;\r\n    }\r\n\r\n    function filterNodesByIds(nodeList, nodeIds) {\r\n      const\r\n        nodesMap = new Map(),\r\n        result = [];\r\n\r\n      nodeList.forEach(node => nodesMap.set(node.id, node));\r\n      nodeIds.forEach((nodeId) => {\r\n        if (nodesMap.has(nodeId)) {\r\n          result.push(nodesMap.get(nodeId));\r\n        }\r\n      });\r\n\r\n      return result;\r\n    }\r\n\r\n    function filterNodesBySubMap(inputNodeList, map, subMapNamesSequence) {\r\n      const nodeIds = getNodeIdsForSubMap(map, [].concat(subMapNamesSequence));\r\n      let filteredNodes = [];\r\n\r\n      if (nodeIds.success) {\r\n        filteredNodes = filterNodesByIds(inputNodeList, nodeIds);\r\n      }\r\n\r\n      return getProcessingResult(\r\n        nodeIds.success,\r\n        filteredNodes\r\n      );\r\n    }\r\n\r\n    function filterNodesByMap(inputNodeList, mapId) {\r\n      const\r\n        map = atlas.atlasMaps.has(mapId) ? atlas.atlasMaps.get(mapId) : null,\r\n        success = (map != null),\r\n        filteredNodes = (success) ? filterNodesByIds(inputNodeList, map.allNodesId) : [];\r\n\r\n      return getProcessingResult(\r\n        success,\r\n        filteredNodes\r\n      );\r\n    }\r\n\r\n    function createNodesTokenProcessor(nodeList) {\r\n      return () => getProcessingResult(true, nodeList);\r\n    }\r\n\r\n    function deviceTypeTokenProcessor(deviceType, nodeList) {\r\n      return getProcessingResult(\r\n        true,\r\n        nodeList.filter(node => node.checkDeviceType(deviceType))\r\n      );\r\n    }\r\n\r\n    function networkMapTokenProcessor(subMapNamesSequence, nodeList) {\r\n      return filterNodesBySubMap(nodeList, atlas.networkAtlasRoot, subMapNamesSequence);\r\n    }\r\n\r\n    function monitoringPackTokenProcessor(parameter, nodeList) {\r\n      const\r\n        monitoringPackPath = parameter.shift() ? parameter : [],\r\n        nodesAtlasMonitoringPack = filterNodesBySubMap(nodeList, atlas.monitoringPacks, monitoringPackPath);\r\n\r\n      if (!nodesAtlasMonitoringPack.success) {\r\n        const monitoringPackId = NetCrunchDefaultEnglishMonitoringPacks.getMonitoringPackId(monitoringPackPath);\r\n\r\n        if (monitoringPackId != null) {\r\n          return filterNodesByMap(nodeList, monitoringPackId);\r\n        }\r\n        return getProcessingResult(false, []);\r\n      }\r\n\r\n      return nodesAtlasMonitoringPack;\r\n    }\r\n\r\n    const\r\n      tokenProcessors = {\r\n        nodes: createNodesTokenProcessor(nodes),\r\n        deviceType: deviceTypeTokenProcessor,\r\n        networkMap: networkMapTokenProcessor,\r\n        monitoringPack: monitoringPackTokenProcessor\r\n      };\r\n    let\r\n      currentToken,\r\n      processingSuccessful = true,\r\n      processingResult,\r\n      nodesForProcessing = [];\r\n\r\n    while (processingSuccessful && (tokens.length > 0)) {\r\n      currentToken = tokens.shift();\r\n      processingResult = tokenProcessors[currentToken.type](currentToken.value, nodesForProcessing);\r\n      processingSuccessful = processingResult.success;\r\n\r\n      if (processingSuccessful) {\r\n        nodesForProcessing = processingResult.nodes;\r\n      }\r\n    }\r\n\r\n    return {\r\n      success: processingSuccessful,\r\n      nodes: nodesForProcessing\r\n    };\r\n  }\r\n\r\n  static createQueryResult(nodes) {\r\n    return (nodes || []).map((node) => {\r\n      const ipAddress = (node.address != null) ? `(${node.address})` : '';\r\n      return {\r\n        text: `${node.name} ${ipAddress}`,\r\n        value: node.id\r\n      };\r\n    });\r\n  }\r\n\r\n}\r\n\r\nexport {\r\n  NetCrunchMetricFindQuery\r\n};\r\n"]}