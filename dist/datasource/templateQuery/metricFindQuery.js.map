{"version":3,"sources":["../../../src/datasource/templateQuery/metricFindQuery.js"],"names":["QueryParser","NetCrunchMetricFindQuery","datasource","query","parsingResult","parseQuery","completeParsed","Promise","all","nodes","atlas","then","result","allNodes","processingResult","processQuery","tokens","createQueryResult","success","resolve","parse","unparsedQuery","residuals","token","value","getProcessingResult","nodeList","getNodeIdsForSubMap","map","subMapNamesSequence","subMap","length","push","allNodesId","getChildMapByDisplayName","shift","filterNodesByIds","nodeIds","nodesMap","Map","forEach","set","node","id","nodeId","has","get","filterNodesBySubMap","inputNodeList","concat","filteredNodes","tokenProcessors","deviceType","filter","checkDeviceType","networkMap","atlasRoot","currentToken","processingSuccessful","nodesForProcessing","type","ipAddress","address","text","name"],"mappings":"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","file":"metricFindQuery.js","sourcesContent":["/**\n * @license\n * Copyright AdRem Software. All Rights Reserved.\n *\n * Use of this source code is governed by an Apache License, Version 2.0 that can be\n * found in the LICENSE file.\n */\n\nimport { QueryParser } from './queryParser';\n\nclass NetCrunchMetricFindQuery {\n\n  constructor(datasource, query) {\n    this.datasource = datasource;\n    this.query = query;\n  }\n\n  process() {\n    const parsingResult = NetCrunchMetricFindQuery.parseQuery(this.query);\n\n    if (parsingResult.completeParsed) {\n      return Promise.all([this.datasource.nodes(), this.datasource.atlas()])\n        .then((result) => {\n          const\n            atlas = result[1],\n            allNodes = result[0].all,\n            processingResult = NetCrunchMetricFindQuery.processQuery(parsingResult.tokens, atlas, allNodes);\n\n          return NetCrunchMetricFindQuery.createQueryResult((processingResult.success) ? processingResult.nodes : []);\n        });\n    }\n\n    return Promise.resolve(NetCrunchMetricFindQuery.createQueryResult([]));\n  }\n\n  static parseQuery(query) {\n    const\n      parsingResult = QueryParser.parse(query),\n      result = {\n        completeParsed: false,\n        unparsedQuery: '',\n        tokens: []\n      };\n\n    if (parsingResult != null) {\n      result.completeParsed = (parsingResult.residuals === '');\n      result.unparsedQuery = parsingResult.residuals;\n      result.tokens = parsingResult.token.value;\n    }\n\n    return result;\n  }\n\n  static processQuery(tokens, atlas, nodes) {\n\n    function getProcessingResult(success, nodeList) {\n      return {\n        success,\n        nodes: nodeList\n      };\n    }\n\n    function getNodeIdsForSubMap(map, subMapNamesSequence) {\n      const result = [];\n      let subMap;\n\n      if (subMapNamesSequence.length === 0) {\n        result.push(...map.allNodesId);\n        result.success = true;\n        return result;\n      }\n\n\n      subMap = map.getChildMapByDisplayName(subMapNamesSequence.shift());         // eslint-disable-line prefer-const\n      if (subMap != null) {\n        return getNodeIdsForSubMap(subMap, subMapNamesSequence);\n      }\n\n      result.success = false;\n      return result;\n    }\n\n    function filterNodesByIds(nodeList, nodeIds) {\n      const\n        nodesMap = new Map(),\n        result = [];\n\n      nodeList.forEach(node => nodesMap.set(node.id, node));\n      nodeIds.forEach((nodeId) => {\n        if (nodesMap.has(nodeId)) {\n          result.push(nodesMap.get(nodeId));\n        }\n      });\n\n      return result;\n    }\n\n    function filterNodesBySubMap(inputNodeList, map, subMapNamesSequence) {\n      const nodeIds = getNodeIdsForSubMap(map, [].concat(subMapNamesSequence));\n      let filteredNodes = [];\n\n      if (nodeIds.success) {\n        filteredNodes = filterNodesByIds(inputNodeList, nodeIds);\n      }\n\n      return getProcessingResult(\n        nodeIds.success,\n        filteredNodes\n      );\n    }\n\n    function createNodesTokenProcessor(nodeList) {\n      return () => getProcessingResult(true, nodeList);\n    }\n\n    function deviceTypeTokenProcessor(deviceType, nodeList) {\n      return getProcessingResult(\n        true,\n        nodeList.filter(node => node.checkDeviceType(deviceType))\n      );\n    }\n\n    function networkMapTokenProcessor(subMapNamesSequence, nodeList) {\n      return filterNodesBySubMap(nodeList, atlas.atlasRoot, subMapNamesSequence);\n    }\n\n    const\n      tokenProcessors = {\n        nodes: createNodesTokenProcessor(nodes),\n        deviceType: deviceTypeTokenProcessor,\n        networkMap: networkMapTokenProcessor\n      };\n    let\n      currentToken,\n      processingSuccessful = true,\n      processingResult,\n      nodesForProcessing = [];\n\n    while (processingSuccessful && (tokens.length > 0)) {\n      currentToken = tokens.shift();\n      processingResult = tokenProcessors[currentToken.type](currentToken.value, nodesForProcessing);\n      processingSuccessful = processingResult.success;\n\n      if (processingSuccessful) {\n        nodesForProcessing = processingResult.nodes;\n      }\n    }\n\n    return {\n      success: processingSuccessful,\n      nodes: nodesForProcessing\n    };\n  }\n\n  static createQueryResult(nodes) {\n    return (nodes || []).map((node) => {\n      const ipAddress = (node.address != null) ? `(${node.address})` : '';\n      return {\n        text: `${node.name} ${ipAddress}`,\n        value: node.id\n      };\n    });\n  }\n\n}\n\nexport {\n  NetCrunchMetricFindQuery\n};\n"]}