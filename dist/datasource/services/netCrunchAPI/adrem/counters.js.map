{"version":3,"sources":["../../../../../src/datasource/services/netCrunchAPI/adrem/counters.js"],"names":["NetCrunchCounters","adremClient","netCrunchConnection","isOid","stringData","indexOf","C_PERSEC","replace","match","stringToCntType","type","MIB_CNT_SRC_ID","counterConsts","CNT_TYPE","cstMIB","cstXML","getCounterPathType","counterPath","pathType","cstSimple","CNT_SRC_SEPARATOR","split","removeCounterPathType","resultPath","parseSNMPPath","snmpPath","objectType","objectValue","snmpPathParts","value","displayStringToSnmpFunc","functionMap","result","SNMP_FUNC","scfUnknown","OVERALL_TOTAL","scfSum","OVERALL_AVERAGE","scfAvg","OVERALL_MAXIMUM","scfMax","OVERALL_MINIMUM","scfMin","OVERALL_COUNT","scfCount","parseShortPath","decodePath","parseOIDPath","oidPath","decodedPath","instOID","obj","objOID","cnt","inst","instType","isPerSec","decodedObjOID","length","SNMP_INSTANCE_TYPE","sitNone","sitByIndex","charAt","substr","sitComputable","sitByLookup","parseXMLPath","xmlPath","hasInstance","getOidPath","oid","oidCache","getOidFunc","updateOidPath","Promise","resolve","initSnmpMibData","snmpMibData","NetCrunch","SnmpMibData","getShortOidPath","shortOidPathsCache","getFullOidPath","fullOidPathsCache","path","parts","CNT_SEPARATOR","slice","join","encodeDisplayPath","withPerSec","ix","perSec","counterToString","decodedCounter","makeShortPath","object","counter","instance","getSNMPDisplayPath","shortPath","showPerSecondValue","displayPath","then","resolvedPath","isKnownMillisecondCounter","toLowerCase","isMillisecondsCounter","c","toUpperCase","contains","isBytesCounter","displayName","resources","metrics","bytes","memory","mbytes","kbytes","getValueFormatting","base1","base","units","range","getValueRange","kilo","getTimeRange","Object","create","counterTypes","NETCRUNCH_COUNTER_TYPES","NETCRUNCH_COUNTER_CONST","unitsToMetric","counterName","counterDisplayName","getMetric","multiplier","percentage","milliseconds","bytesBitsPS","getDisplayValue","metric","mparts","m","isBPS","isBytes","bytesBps","isMS","v","isNaN","Math","round","isMIBCnt","counterPathObject","counterType","XML_CNT_SRC_ID","removePerSecond","parseCounterPath","counterPathType","parsedCounterPath","encodePath","p","push","addInstance","decodeDisplayPath","objParts","fmt","some","s","forEach","i","removePerSec","counterPathToDisplayStr","showPerSecValue","knownMSCounters","sitValue"],"mappings":"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","file":"counters.js","sourcesContent":["/**\n * @license\n * Copyright AdRem Software. All Rights Reserved.\n *\n * Use of this source code is governed by an Apache License, Version 2.0 that can be\n * found in the LICENSE file.\n */\n\n/* eslint-disable no-param-reassign */\n\nconst\n  C_PERSEC = '/sec',\n  CNT_SEPARATOR = '|',\n  CNT_SRC_SEPARATOR = '&',\n  MIB_CNT_SRC_ID = 'MIB',\n  XML_CNT_SRC_ID = 'XML',\n\n  // Overall counter instances\n  OVERALL_TOTAL = '_Total',\n  OVERALL_MAXIMUM = '_Maximum',\n  OVERALL_MINIMUM = '_Minimum',\n  OVERALL_AVERAGE = '_Average',\n  OVERALL_COUNT = '_Count',\n\n  knownMSCounters = ['load time', 'check time', 'round trip time'],\n\n  NETCRUNCH_COUNTER_CONST = {\n    CNT_TYPE: {\n      cstXML: 1,\n      cstMIB: 2,\n      cstSimple: 3\n    },\n\n    SNMP_INSTANCE_TYPE: {\n      sitValue: 1,\n      sitNone: 2,\n      sitByIndex: 3,\n      sitByLookup: 4,\n      sitComputable: 5\n    },\n\n    SNMP_FUNC: {\n      scfUnknown: 1,\n      scfSum: 2,\n      scfMin: 3,\n      scfMax: 4,\n      scfAvg: 5,\n      scfCount: 6\n    }\n  },\n\n  NETCRUNCH_COUNTER_TYPES = {\n    percentage: '%',\n    milliseconds: 'ms',\n    bytesBitsPS: 'bps',\n    bytesBps: 'Bps',\n    bytes: 'bytes'\n  };\n\nfunction NetCrunchCounters(adremClient, netCrunchConnection) {\n\n  let snmpMibData = null;\n  const\n    shortOidPathsCache = Object.create(null),\n    fullOidPathsCache = Object.create(null),\n    cnSCT = 'Check Time',\n    cnRTT = 'Round Trip Time',\n    resources = Object.create(null),\n    counterTypes = NETCRUNCH_COUNTER_TYPES,\n    counterConsts = NETCRUNCH_COUNTER_CONST;\n\n  function isOid(stringData) {\n    if (stringData.indexOf(C_PERSEC) >= 0) {\n      stringData = stringData.replace(C_PERSEC, '');\n    }\n    return (stringData.match(/^((([0-9]+)\\.)+[0-9]+)$/) != null);\n  }\n\n  function isMIBCnt(obj, cnt) {\n    return (((isOid(obj) === true) && ((cnt === '') || (isOid(cnt) === true))) ||\n            ((obj === '') && (isOid(cnt) === true)));\n  }\n\n  function counterPathObject(counter, counterType) {\n    if (counterType !== counterConsts.CNT_TYPE.cstSimple) {\n      if (counterType === counterConsts.CNT_TYPE.cstXML) {\n        return XML_CNT_SRC_ID + CNT_SRC_SEPARATOR + counter;\n      }\n      if (counterType === counterConsts.CNT_TYPE.cstMIB) {\n        return MIB_CNT_SRC_ID + CNT_SRC_SEPARATOR + counter;\n      }\n    }\n    return counter;\n  }\n\n  function stringToCntType(type) {\n    if (type === MIB_CNT_SRC_ID) {\n      return counterConsts.CNT_TYPE.cstMIB;\n    }\n    return counterConsts.CNT_TYPE.cstXML;\n  }\n\n  function getCounterPathType(counterPath) {\n    let pathType;\n\n    pathType = counterConsts.CNT_TYPE.cstSimple;\n\n    if (counterPath.indexOf(CNT_SRC_SEPARATOR) > 0) {\n      pathType = stringToCntType(counterPath.split(CNT_SRC_SEPARATOR)[0]);\n    }\n    return pathType;\n  }\n\n  function removeCounterPathType(counterPath) {\n    let resultPath = counterPath;\n\n    if (counterPath.indexOf(CNT_SRC_SEPARATOR) > 0) {\n      resultPath = counterPath.split(CNT_SRC_SEPARATOR)[1];\n    }\n\n    return resultPath;\n  }\n\n  function removePerSecond(stringData) {\n    return stringData.replace(C_PERSEC, '');\n  }\n\n  function parseSNMPPath(snmpPath) {\n    let\n      objectType,\n      objectValue,\n      snmpPathParts;\n\n    if (snmpPath.indexOf(CNT_SRC_SEPARATOR) < 0) {\n      objectType = counterConsts.CNT_TYPE.cstXML;\n      objectValue = snmpPath;\n    } else {\n      snmpPathParts = snmpPath.split(CNT_SRC_SEPARATOR);\n      objectType = stringToCntType(snmpPathParts[0]);\n      objectValue = snmpPathParts[1];\n    }\n\n    return {\n      type: objectType,\n      value: objectValue\n    };\n  }\n\n  function displayStringToSnmpFunc(stringData) {\n    const functionMap = {};\n    let result = counterConsts.SNMP_FUNC.scfUnknown;\n\n    functionMap[OVERALL_TOTAL] = counterConsts.SNMP_FUNC.scfSum;\n    functionMap[OVERALL_AVERAGE] = counterConsts.SNMP_FUNC.scfAvg;\n    functionMap[OVERALL_MAXIMUM] = counterConsts.SNMP_FUNC.scfMax;\n    functionMap[OVERALL_MINIMUM] = counterConsts.SNMP_FUNC.scfMin;\n    functionMap[OVERALL_COUNT] = counterConsts.SNMP_FUNC.scfCount;\n\n    if (functionMap[stringData] != null) {\n      result = functionMap[stringData];\n    }\n    return result;\n  }\n\n  function parseShortPath(counterPath) {\n    // eslint-disable-next-line\n    return decodePath(counterPath);\n  }\n\n  function parseOIDPath(oidPath) {\n    const\n      decodedPath = parseShortPath(oidPath),\n      instOID = decodedPath.obj;\n    let\n      objOID = decodedPath.cnt,\n      inst = decodedPath.inst,\n      instType,\n      isPerSec = (objOID.indexOf(C_PERSEC) >= 0),     //eslint-disable-line\n      decodedObjOID;\n\n    if (isPerSec === true) {\n      objOID = objOID.replace(C_PERSEC, '');\n    }\n\n    if ((inst === '') || (inst === '-')) {\n      decodedObjOID = objOID.match(/(.*)\\.([0-9]+)$/);\n      if (decodedObjOID.length > 1) {\n        objOID = decodedObjOID[1];\n        inst = decodedObjOID[2];\n      }\n\n      if (inst === '0') {\n        instType = counterConsts.SNMP_INSTANCE_TYPE.sitNone;\n      } else {\n        instType = counterConsts.SNMP_INSTANCE_TYPE.sitByIndex;\n      }\n    } else if (inst.charAt(0) === '#') {\n      inst = inst.substr(1);\n      instType = counterConsts.SNMP_INSTANCE_TYPE.sitByIndex;\n    } else if ((inst.charAt(0) === '_') && (displayStringToSnmpFunc(inst) !== counterConsts.SNMP_FUNC.scfUnknown)) {\n      instType = counterConsts.SNMP_INSTANCE_TYPE.sitComputable;\n    } else {\n      instType = counterConsts.SNMP_INSTANCE_TYPE.sitByLookup;\n    }\n\n    return {\n      objOID,\n      instOID,\n      inst,\n      isPerSec,\n      type: instType\n    };\n  }\n\n  function parseXMLPath(xmlPath, hasInstance) {\n    const decodedPath = parseShortPath(xmlPath);\n    let\n      inst = decodedPath.inst,\n      instType;\n\n    if (hasInstance === true) {\n      instType = counterConsts.SNMP_INSTANCE_TYPE.sitByLookup;\n\n      if (inst !== '') {\n        if (inst.charAt(0) === '#') {\n          inst = inst.substr(1);\n          instType = counterConsts.SNMP_INSTANCE_TYPE.sitByIndex;\n        } else if (inst.charAt(0) === '_') {\n          instType = counterConsts.SNMP_INSTANCE_TYPE.sitComputable;\n        }\n      } else if ((inst === '') || (inst === '-')) {\n        instType = counterConsts.SNMP_INSTANCE_TYPE.sitNone;\n      } else {\n        instType = counterConsts.SNMP_INSTANCE_TYPE.sitByLookup;\n      }\n\n      decodedPath.inst = inst;\n      decodedPath.type = instType;\n    }\n\n    return decodedPath;\n  }\n\n  function parseCounterPath(counterPath) {\n    const counterPathType = getCounterPathType(counterPath);\n    let parsedCounterPath;\n\n    if (counterPathType === counterConsts.CNT_TYPE.cstXML) {\n      parsedCounterPath = parseXMLPath(counterPath, true);\n    } else if (counterPathType === counterConsts.CNT_TYPE.cstMIB) {\n      parsedCounterPath = parseOIDPath(removeCounterPathType(counterPath));\n      parsedCounterPath.obj = parsedCounterPath.objOID;\n      parsedCounterPath.cnt = '';\n      if (parsedCounterPath.inst === '') {\n        parsedCounterPath.inst = parsedCounterPath.instOID;\n      }\n    } else if (counterPathType === counterConsts.CNT_TYPE.cstSimple) {\n      parsedCounterPath = parseShortPath(counterPath);\n    }\n\n    return parsedCounterPath;\n  }\n\n  function getOidPath(oid, oidCache, getOidFunc) {\n    let updateOidPath = false;\n\n    return new Promise((resolve) => {\n      if (oidCache[oid] == null) {\n        oidCache[oid] = oid;\n        updateOidPath = true;\n      } else if (oidCache[oid] === oid) {\n        updateOidPath = true;\n      }\n\n      if (updateOidPath === true) {\n        getOidFunc({ oid }, (oidPath) => {\n          oidCache[oid] = oidPath;\n          resolve(oidPath);\n        });\n      } else {\n        resolve(oidCache[oid]);\n      }\n    });\n  }\n\n  function initSnmpMibData() {\n    if (snmpMibData == null) {\n      snmpMibData = new adremClient.NetCrunch.SnmpMibData('ncSrv', () => {}, netCrunchConnection);\n    }\n  }\n\n  function getShortOidPath(oid) {\n    initSnmpMibData();\n    return getOidPath(oid, shortOidPathsCache, snmpMibData.getShortOidPath);\n  }\n\n  function getFullOidPath(oid) {\n    initSnmpMibData();\n    return getOidPath(oid, fullOidPathsCache, snmpMibData.getFullOidPath);\n  }\n\n  function decodePath(path) {\n    const\n      parts = path.split(CNT_SEPARATOR),\n      result = {};\n\n    result.obj = parts[0];\n    result.cnt = parts.length > 1 ? parts[1] : '';\n    if (parts.length === 3) {\n      result.inst = parts[2];\n    } else if (parts.length > 3) {\n      result.inst = parts.slice(2).join(CNT_SEPARATOR);\n    } else {\n      result.inst = '';\n    }\n    return result;\n  }\n\n  function encodePath(parts) {\n    const p = [parts.obj, parts.cnt];\n    if (parts.inst !== '') {\n      p.push(parts.inst);\n    }\n    return p.join(CNT_SEPARATOR);\n  }\n\n  function decodeDisplayPath(displayPath) {\n    const\n      result = { obj: '', cnt: '', inst: '' },\n      ix = displayPath.indexOf(C_PERSEC),\n      perSec = (ix >= 0);\n    let objParts;\n\n    if (perSec) {\n      displayPath = displayPath.substr(0, ix);\n    }\n\n    if (![\n          { fmt: new RegExp('(.+)\\\\((.+)\\\\)\\\\\\\\(.+)'), parts: ['obj', 'inst', 'cnt'] }, // obj(inst)\\cnt\n          { fmt: new RegExp('(.+)\\\\((.+)\\\\)'), parts: ['obj', 'inst'] }, // obj(inst)\n          { fmt: new RegExp('(.+)\\\\\\\\(.+)'), parts: ['obj', 'cnt'] } // obj\\cnt\n        ].some((s) => {                             //eslint-disable-line\n          const parts = displayPath.match(s.fmt);\n          if (parts != null) {\n            s.parts.forEach((p, i) => {\n              result[p] = parts[i + 1];\n            });\n            return true;\n          }\n          return false;\n        })) {\n      // formats do not match\n      result.obj = displayPath;\n    }\n    // Fix SNMP column path\n    if (result.cnt === '' && result.obj !== '') {\n      if (result.obj.match('^[0-9\\\\.]+(\\\\.[0-9]+)$')) {\n        result.cnt = '';\n        if (result.inst !== '') {\n          result.obj = `${result.obj}.${result.inst}`;\n          result.inst = '';\n        }\n      } else if (result.obj.indexOf('.') >= 0) {\n        objParts = result.obj.split('.');\n        result.cnt = objParts[1];\n        result.obj = objParts[0];\n      } else {\n        result.cnt = result.obj;\n        result.obj = '';\n      }\n    }\n    result.perSec = perSec;\n    if (perSec) {\n      result.cnt += C_PERSEC;\n    }\n    return result;\n  }\n\n  function removePerSec(displayName) {\n    const ix = displayName.indexOf(C_PERSEC);\n    // todo: check if ix == displayName.length - C_PERSEC.length\n    return displayName.substr(0, ix);\n  }\n\n  function encodeDisplayPath(parts, withPerSec) {\n    let\n      result = parts.obj,\n      ix;\n    withPerSec = (withPerSec == null) ? true : withPerSec;\n\n    if (parts.inst !== '' && parts.inst != null) {\n      result = `${parts.obj}(${parts.inst})`;\n    }\n\n    if (parts.cnt !== '' && parts.cnt != null) {\n      if (!withPerSec && parts.perSec) { // remove /sec from counter name\n        ix = parts.cnt.indexOf(C_PERSEC);\n        result = `${result}\\\\${parts.cnt.substr(0, ix)}`;\n      } else {\n        result = `${result}\\\\${parts.cnt}`;\n      }\n    }\n    return result;\n  }\n\n  function counterToString(counterPath) {\n    const decodedCounter = decodePath(counterPath);\n    return encodeDisplayPath(decodedCounter, true);\n  }\n\n  function makeShortPath(object, counter, instance) {\n    if (instance === '') {\n      return object + CNT_SEPARATOR + counter;\n    }\n    return object + CNT_SEPARATOR + counter + CNT_SEPARATOR + instance;\n  }\n\n  function getSNMPDisplayPath(counterPath, shortPath, showPerSecondValue) {\n    const snmpPath = parseSNMPPath(counterPath);\n    let\n      oidPath,\n      displayPath = Promise.resolve(null);\n\n    if (snmpPath.type === counterConsts.CNT_TYPE.cstXML) {\n      displayPath = Promise.resolve(counterToString(snmpPath.value));\n    } else if (snmpPath.type === counterConsts.CNT_TYPE.cstMIB) {\n      oidPath = parseOIDPath(counterPath);\n      if (shortPath === true) {\n        displayPath = getShortOidPath(oidPath.objOID);\n      } else {\n        displayPath = getFullOidPath(oidPath.objOID);\n      }\n\n      return displayPath\n        .then((resolvedPath) => {\n          if ((resolvedPath == null) || (resolvedPath === '')) {\n            resolvedPath = oidPath.objOID;\n          }\n          if (oidPath.inst === '0') {\n            oidPath.inst = '';\n          }\n\n          resolvedPath = counterToString(makeShortPath(resolvedPath, '', oidPath.inst));\n\n          if ((showPerSecondValue === true) && (oidPath.isPerSec === true)) {\n            resolvedPath += C_PERSEC;\n          }\n          return resolvedPath;\n        });\n    }\n\n    return displayPath;\n  }\n\n  function counterPathToDisplayStr(counterPath, shortPath, showPerSecValue) {\n    const pathType = getCounterPathType(counterPath);\n\n    if ((pathType === counterConsts.CNT_TYPE.cstXML) || (pathType === counterConsts.CNT_TYPE.cstMIB)) {\n      return getSNMPDisplayPath(counterPath, shortPath, showPerSecValue);\n    }\n    return Promise.resolve(counterToString(counterPath));\n  }\n\n  function isKnownMillisecondCounter(cnt) {\n    return knownMSCounters.indexOf(cnt.toLowerCase()) >= 0;\n  }\n\n  /**\n   * isMillisecondsCounter(\n   * @param counter\n   * @returns {boolean}\n   */\n  function isMillisecondsCounter(counter) {\n    const c = decodePath(counter);\n    return ((c.cnt === cnRTT) || (c.cnt === cnSCT) ||\n            (c.cnt.toUpperCase().indexOf('MILLISECOND') >= 0) || isKnownMillisecondCounter(c.cnt));\n  }\n\n  function contains(cnt, substr) {\n    return cnt.indexOf(substr) >= 0;\n  }\n\n  /**\n   * isBytesCounter\n   * @param displayName\n   * @returns {null|''|'M'|'K'}\n   */\n  function isBytesCounter(displayName) {\n    const cnt = displayName.toLowerCase();\n    let result = '';\n\n    if (contains(cnt, resources.metrics.bytes) || contains(cnt, resources.metrics.memory) || contains(cnt, 'octet')) {\n      if (contains(cnt, resources.metrics.mbytes) || contains(cnt, 'mega')) {\n        result = 'M';\n      } else if (contains(cnt, resources.metrics.kbytes) || contains(cnt, 'kilo')) {\n        result = 'K';\n      }\n      return result;\n    }\n    return null;\n  }\n\n  function getValueFormatting(value, base1, base, units = ['K', 'M', 'G']) {\n    let range = '';\n    if (value >= 1 * base1 && value < base1 * base) {\n      value /= base1;\n      range = units[0];\n    } else if (value >= base1 * base && value < base1 * base * base) {\n      value = value / base1 / base;\n      range = units[1];\n    } else if (value >= base1 * base * base) {\n      value = value / base1 / base / base;\n      range = units[2];\n    }\n    return {\n      value,\n      units: range\n    };\n  }\n\n  function getValueRange(value, kilo) {\n    return getValueFormatting(value, kilo, kilo);\n  }\n\n  function getTimeRange(value) {\n    return getValueFormatting(value, 1000, 60, ['sec', 'min', 'hrs']);\n  }\n\n  return {\n    unitsToMetric: (units, counterName, counterDisplayName) => {\n      if (units === 'bytestobps') {\n        return 'bps';\n      } else if (units === 'percentage') {\n        return '%';\n      } else if (units === 'bytesps') {\n        return 'Bps';\n      } else if (units === 'bytes') {\n        return 'bytes';\n      }\n      return this.getMetric(counterName, counterDisplayName);\n    },\n\n    /**\n     * Get Metric for Counter\n     * @param counterPath\n     * @param displayName\n     * @returns {*}\n     */\n    getMetric: (counterPath, displayName) => {\n      let multiplier;\n      if (contains(displayName, '%')) {\n        return counterTypes.percentage;\n      } else if (!isMillisecondsCounter(counterPath)) {\n        multiplier = isBytesCounter(displayName);\n        if (multiplier !== null) {\n          if (multiplier !== '') {\n            multiplier = `'#${multiplier}`;\n          }\n          if (contains(displayName, C_PERSEC) || contains(displayName, 'per sec.')) { // ESX counters are \"per sec.\"\n            return counterTypes.bytesBitsPS + multiplier;\n          }\n          return counterTypes.bytes + multiplier;\n        }\n        return '';\n      }\n      return counterTypes.milliseconds;\n    },\n\n    getDisplayValue: (value, metric) => {\n      const\n        mparts = metric.split('#'),\n        m = mparts[0],\n        multiplier = mparts.length > 1 ? mparts[1] : '',\n        isBPS = (m === counterTypes.bytesBitsPS),\n        isBytes = (m === counterTypes.bytes) || isBPS || (m === counterTypes.bytesBps),\n        isMS = (m === counterTypes.milliseconds),\n        isNoUnits = (m === '');\n      let v;\n\n      if (value == null || isNaN(value)) {\n        return { value, units: '' };\n      } else {                                            //eslint-disable-line\n        if (isBPS) {\n          value *= 8;\n        }\n        if (multiplier !== '') {\n          return {\n            value: Math.round(value * 100) / 100,\n            units: multiplier + (isBytes ? 'B' : '')\n          };\n        }\n        if (isBytes) {\n          v = getValueRange(value, 1024);\n          if (m === counterTypes.bytes) {\n            v.units += 'B';\n          } else {\n            v.units += m;\n          }\n        } else if (isNoUnits) {\n          v = getValueRange(value, 1000);\n        } else if (isMS) {\n          v = getTimeRange(value);\n          if (v.units === '') {\n            v.units = counterTypes.milliseconds;\n          }\n        } else {\n          v = {\n            value,\n            units: m\n          };\n        }\n        return {\n          value: v.value,\n          units: v.units\n        };\n      }\n    },\n\n    isOid,\n    isMIBCnt,\n    counterPathObject,\n    stringToCntType,\n    getCounterPathType,\n    removeCounterPathType,\n    removePerSecond,\n    parseSNMPPath,\n    parseOIDPath,\n    parseXMLPath,\n    parseCounterPath,\n    getShortOidPath,\n    getFullOidPath,\n    decodePath,\n    encodePath,\n    addInstance: (path, inst) => {\n      if (inst !== '') {\n        return path + CNT_SEPARATOR + inst;\n      }\n      return path;\n    },\n    decodeDisplayPath,\n    encodeDisplayPath,\n    removePerSec,\n    getSNMPDisplayPath,\n    counterPathToDisplayStr\n  };\n}\n\nexport {\n  NETCRUNCH_COUNTER_CONST,\n  NETCRUNCH_COUNTER_TYPES,\n  NetCrunchCounters\n};\n"]}