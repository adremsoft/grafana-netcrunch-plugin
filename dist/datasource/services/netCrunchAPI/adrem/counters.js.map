{"version":3,"sources":["../../../../../src/datasource/services/netCrunchAPI/adrem/counters.js"],"names":["NetCrunchCounters","adremClient","netCrunchConnection","isOid","stringData","indexOf","C_PERSEC","replace","match","stringToCntType","type","MIB_CNT_SRC_ID","counterConsts","CNT_TYPE","cstMIB","cstXML","getCounterPathType","counterPath","pathType","cstSimple","CNT_SRC_SEPARATOR","split","removeCounterPathType","resultPath","parseSNMPPath","snmpPath","objectType","objectValue","snmpPathParts","value","displayStringToSnmpFunc","functionMap","result","SNMP_FUNC","scfUnknown","OVERALL_TOTAL","scfSum","OVERALL_AVERAGE","scfAvg","OVERALL_MAXIMUM","scfMax","OVERALL_MINIMUM","scfMin","OVERALL_COUNT","scfCount","parseShortPath","decodePath","parseOIDPath","oidPath","decodedPath","instOID","obj","objOID","cnt","inst","instType","isPerSec","decodedObjOID","length","SNMP_INSTANCE_TYPE","sitNone","sitByIndex","charAt","substr","sitComputable","sitByLookup","parseXMLPath","xmlPath","hasInstance","getOidPath","oid","oidCache","getOidFunc","updateOidPath","Promise","resolve","initSnmpMibData","snmpMibData","NetCrunch","SnmpMibData","getShortOidPath","shortOidPathsCache","getFullOidPath","fullOidPathsCache","path","parts","CNT_SEPARATOR","slice","join","encodeDisplayPath","withPerSec","ix","perSec","counterToString","decodedCounter","makeShortPath","object","counter","instance","getSNMPDisplayPath","shortPath","showPerSecondValue","displayPath","then","resolvedPath","isKnownMillisecondCounter","toLowerCase","isMillisecondsCounter","c","toUpperCase","contains","isBytesCounter","displayName","resources","metrics","bytes","memory","mbytes","kbytes","getValueFormatting","base1","base","units","range","getValueRange","kilo","getTimeRange","Object","create","counterTypes","NETCRUNCH_COUNTER_TYPES","NETCRUNCH_COUNTER_CONST","unitsToMetric","counterName","counterDisplayName","getMetric","multiplier","percentage","milliseconds","bytesBitsPS","getDisplayValue","metric","mparts","m","isBPS","isBytes","bytesBps","isMS","v","isNaN","Math","round","isMIBCnt","counterPathObject","counterType","XML_CNT_SRC_ID","removePerSecond","parseCounterPath","counterPathType","parsedCounterPath","encodePath","p","push","addInstance","decodeDisplayPath","objParts","fmt","some","s","forEach","i","removePerSec","counterPathToDisplayStr","showPerSecValue","knownMSCounters","sitValue"],"mappings":"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","file":"counters.js","sourcesContent":["/**\r\n * @license\r\n * Copyright AdRem Software. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an Apache License, Version 2.0 that can be\r\n * found in the LICENSE file.\r\n */\r\n\r\n/* eslint-disable no-param-reassign */\r\n\r\nconst\r\n  C_PERSEC = '/sec',\r\n  CNT_SEPARATOR = '|',\r\n  CNT_SRC_SEPARATOR = '&',\r\n  MIB_CNT_SRC_ID = 'MIB',\r\n  XML_CNT_SRC_ID = 'XML',\r\n\r\n  // Overall counter instances\r\n  OVERALL_TOTAL = '_Total',\r\n  OVERALL_MAXIMUM = '_Maximum',\r\n  OVERALL_MINIMUM = '_Minimum',\r\n  OVERALL_AVERAGE = '_Average',\r\n  OVERALL_COUNT = '_Count',\r\n\r\n  knownMSCounters = ['load time', 'check time', 'round trip time'],\r\n\r\n  NETCRUNCH_COUNTER_CONST = {\r\n    CNT_TYPE: {\r\n      cstXML: 1,\r\n      cstMIB: 2,\r\n      cstSimple: 3\r\n    },\r\n\r\n    SNMP_INSTANCE_TYPE: {\r\n      sitValue: 1,\r\n      sitNone: 2,\r\n      sitByIndex: 3,\r\n      sitByLookup: 4,\r\n      sitComputable: 5\r\n    },\r\n\r\n    SNMP_FUNC: {\r\n      scfUnknown: 1,\r\n      scfSum: 2,\r\n      scfMin: 3,\r\n      scfMax: 4,\r\n      scfAvg: 5,\r\n      scfCount: 6\r\n    }\r\n  },\r\n\r\n  NETCRUNCH_COUNTER_TYPES = {\r\n    percentage: '%',\r\n    milliseconds: 'ms',\r\n    bytesBitsPS: 'bps',\r\n    bytesBps: 'Bps',\r\n    bytes: 'bytes'\r\n  };\r\n\r\nfunction NetCrunchCounters(adremClient, netCrunchConnection) {\r\n\r\n  let snmpMibData = null;\r\n  const\r\n    shortOidPathsCache = Object.create(null),\r\n    fullOidPathsCache = Object.create(null),\r\n    cnSCT = 'Check Time',\r\n    cnRTT = 'Round Trip Time',\r\n    resources = Object.create(null),\r\n    counterTypes = NETCRUNCH_COUNTER_TYPES,\r\n    counterConsts = NETCRUNCH_COUNTER_CONST;\r\n\r\n  function isOid(stringData) {\r\n    if (stringData.indexOf(C_PERSEC) >= 0) {\r\n      stringData = stringData.replace(C_PERSEC, '');\r\n    }\r\n    return (stringData.match(/^((([0-9]+)\\.)+[0-9]+)$/) != null);\r\n  }\r\n\r\n  function isMIBCnt(obj, cnt) {\r\n    return (((isOid(obj) === true) && ((cnt === '') || (isOid(cnt) === true))) ||\r\n            ((obj === '') && (isOid(cnt) === true)));\r\n  }\r\n\r\n  function counterPathObject(counter, counterType) {\r\n    if (counterType !== counterConsts.CNT_TYPE.cstSimple) {\r\n      if (counterType === counterConsts.CNT_TYPE.cstXML) {\r\n        return XML_CNT_SRC_ID + CNT_SRC_SEPARATOR + counter;\r\n      }\r\n      if (counterType === counterConsts.CNT_TYPE.cstMIB) {\r\n        return MIB_CNT_SRC_ID + CNT_SRC_SEPARATOR + counter;\r\n      }\r\n    }\r\n    return counter;\r\n  }\r\n\r\n  function stringToCntType(type) {\r\n    if (type === MIB_CNT_SRC_ID) {\r\n      return counterConsts.CNT_TYPE.cstMIB;\r\n    }\r\n    return counterConsts.CNT_TYPE.cstXML;\r\n  }\r\n\r\n  function getCounterPathType(counterPath) {\r\n    let pathType;\r\n\r\n    pathType = counterConsts.CNT_TYPE.cstSimple;\r\n\r\n    if (counterPath.indexOf(CNT_SRC_SEPARATOR) > 0) {\r\n      pathType = stringToCntType(counterPath.split(CNT_SRC_SEPARATOR)[0]);\r\n    }\r\n    return pathType;\r\n  }\r\n\r\n  function removeCounterPathType(counterPath) {\r\n    let resultPath = counterPath;\r\n\r\n    if (counterPath.indexOf(CNT_SRC_SEPARATOR) > 0) {\r\n      resultPath = counterPath.split(CNT_SRC_SEPARATOR)[1];\r\n    }\r\n\r\n    return resultPath;\r\n  }\r\n\r\n  function removePerSecond(stringData) {\r\n    return stringData.replace(C_PERSEC, '');\r\n  }\r\n\r\n  function parseSNMPPath(snmpPath) {\r\n    let\r\n      objectType,\r\n      objectValue,\r\n      snmpPathParts;\r\n\r\n    if (snmpPath.indexOf(CNT_SRC_SEPARATOR) < 0) {\r\n      objectType = counterConsts.CNT_TYPE.cstXML;\r\n      objectValue = snmpPath;\r\n    } else {\r\n      snmpPathParts = snmpPath.split(CNT_SRC_SEPARATOR);\r\n      objectType = stringToCntType(snmpPathParts[0]);\r\n      objectValue = snmpPathParts[1];\r\n    }\r\n\r\n    return {\r\n      type: objectType,\r\n      value: objectValue\r\n    };\r\n  }\r\n\r\n  function displayStringToSnmpFunc(stringData) {\r\n    const functionMap = {};\r\n    let result = counterConsts.SNMP_FUNC.scfUnknown;\r\n\r\n    functionMap[OVERALL_TOTAL] = counterConsts.SNMP_FUNC.scfSum;\r\n    functionMap[OVERALL_AVERAGE] = counterConsts.SNMP_FUNC.scfAvg;\r\n    functionMap[OVERALL_MAXIMUM] = counterConsts.SNMP_FUNC.scfMax;\r\n    functionMap[OVERALL_MINIMUM] = counterConsts.SNMP_FUNC.scfMin;\r\n    functionMap[OVERALL_COUNT] = counterConsts.SNMP_FUNC.scfCount;\r\n\r\n    if (functionMap[stringData] != null) {\r\n      result = functionMap[stringData];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function parseShortPath(counterPath) {\r\n    // eslint-disable-next-line\r\n    return decodePath(counterPath);\r\n  }\r\n\r\n  function parseOIDPath(oidPath) {\r\n    const\r\n      decodedPath = parseShortPath(oidPath),\r\n      instOID = decodedPath.obj;\r\n    let\r\n      objOID = decodedPath.cnt,\r\n      inst = decodedPath.inst,\r\n      instType,\r\n      isPerSec = (objOID.indexOf(C_PERSEC) >= 0),     //eslint-disable-line\r\n      decodedObjOID;\r\n\r\n    if (isPerSec === true) {\r\n      objOID = objOID.replace(C_PERSEC, '');\r\n    }\r\n\r\n    if ((inst === '') || (inst === '-')) {\r\n      decodedObjOID = objOID.match(/(.*)\\.([0-9]+)$/);\r\n      if (decodedObjOID.length > 1) {\r\n        objOID = decodedObjOID[1];\r\n        inst = decodedObjOID[2];\r\n      }\r\n\r\n      if (inst === '0') {\r\n        instType = counterConsts.SNMP_INSTANCE_TYPE.sitNone;\r\n      } else {\r\n        instType = counterConsts.SNMP_INSTANCE_TYPE.sitByIndex;\r\n      }\r\n    } else if (inst.charAt(0) === '#') {\r\n      inst = inst.substr(1);\r\n      instType = counterConsts.SNMP_INSTANCE_TYPE.sitByIndex;\r\n    } else if ((inst.charAt(0) === '_') && (displayStringToSnmpFunc(inst) !== counterConsts.SNMP_FUNC.scfUnknown)) {\r\n      instType = counterConsts.SNMP_INSTANCE_TYPE.sitComputable;\r\n    } else {\r\n      instType = counterConsts.SNMP_INSTANCE_TYPE.sitByLookup;\r\n    }\r\n\r\n    return {\r\n      objOID,\r\n      instOID,\r\n      inst,\r\n      isPerSec,\r\n      type: instType\r\n    };\r\n  }\r\n\r\n  function parseXMLPath(xmlPath, hasInstance) {\r\n    const decodedPath = parseShortPath(xmlPath);\r\n    let\r\n      inst = decodedPath.inst,\r\n      instType;\r\n\r\n    if (hasInstance === true) {\r\n      instType = counterConsts.SNMP_INSTANCE_TYPE.sitByLookup;\r\n\r\n      if (inst !== '') {\r\n        if (inst.charAt(0) === '#') {\r\n          inst = inst.substr(1);\r\n          instType = counterConsts.SNMP_INSTANCE_TYPE.sitByIndex;\r\n        } else if (inst.charAt(0) === '_') {\r\n          instType = counterConsts.SNMP_INSTANCE_TYPE.sitComputable;\r\n        }\r\n      } else if ((inst === '') || (inst === '-')) {\r\n        instType = counterConsts.SNMP_INSTANCE_TYPE.sitNone;\r\n      } else {\r\n        instType = counterConsts.SNMP_INSTANCE_TYPE.sitByLookup;\r\n      }\r\n\r\n      decodedPath.inst = inst;\r\n      decodedPath.type = instType;\r\n    }\r\n\r\n    return decodedPath;\r\n  }\r\n\r\n  function parseCounterPath(counterPath) {\r\n    const counterPathType = getCounterPathType(counterPath);\r\n    let parsedCounterPath;\r\n\r\n    if (counterPathType === counterConsts.CNT_TYPE.cstXML) {\r\n      parsedCounterPath = parseXMLPath(counterPath, true);\r\n    } else if (counterPathType === counterConsts.CNT_TYPE.cstMIB) {\r\n      parsedCounterPath = parseOIDPath(removeCounterPathType(counterPath));\r\n      parsedCounterPath.obj = parsedCounterPath.objOID;\r\n      parsedCounterPath.cnt = '';\r\n      if (parsedCounterPath.inst === '') {\r\n        parsedCounterPath.inst = parsedCounterPath.instOID;\r\n      }\r\n    } else if (counterPathType === counterConsts.CNT_TYPE.cstSimple) {\r\n      parsedCounterPath = parseShortPath(counterPath);\r\n    }\r\n\r\n    return parsedCounterPath;\r\n  }\r\n\r\n  function getOidPath(oid, oidCache, getOidFunc) {\r\n    let updateOidPath = false;\r\n\r\n    return new Promise((resolve) => {\r\n      if (oidCache[oid] == null) {\r\n        oidCache[oid] = oid;\r\n        updateOidPath = true;\r\n      } else if (oidCache[oid] === oid) {\r\n        updateOidPath = true;\r\n      }\r\n\r\n      if (updateOidPath === true) {\r\n        getOidFunc({ oid }, (oidPath) => {\r\n          oidCache[oid] = oidPath;\r\n          resolve(oidPath);\r\n        });\r\n      } else {\r\n        resolve(oidCache[oid]);\r\n      }\r\n    });\r\n  }\r\n\r\n  function initSnmpMibData() {\r\n    if (snmpMibData == null) {\r\n      snmpMibData = new adremClient.NetCrunch.SnmpMibData('ncSrv', () => {}, netCrunchConnection);\r\n    }\r\n  }\r\n\r\n  function getShortOidPath(oid) {\r\n    initSnmpMibData();\r\n    return getOidPath(oid, shortOidPathsCache, snmpMibData.getShortOidPath);\r\n  }\r\n\r\n  function getFullOidPath(oid) {\r\n    initSnmpMibData();\r\n    return getOidPath(oid, fullOidPathsCache, snmpMibData.getFullOidPath);\r\n  }\r\n\r\n  function decodePath(path) {\r\n    const\r\n      parts = path.split(CNT_SEPARATOR),\r\n      result = {};\r\n\r\n    result.obj = parts[0];\r\n    result.cnt = parts.length > 1 ? parts[1] : '';\r\n    if (parts.length === 3) {\r\n      result.inst = parts[2];\r\n    } else if (parts.length > 3) {\r\n      result.inst = parts.slice(2).join(CNT_SEPARATOR);\r\n    } else {\r\n      result.inst = '';\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function encodePath(parts) {\r\n    const p = [parts.obj, parts.cnt];\r\n    if (parts.inst !== '') {\r\n      p.push(parts.inst);\r\n    }\r\n    return p.join(CNT_SEPARATOR);\r\n  }\r\n\r\n  function decodeDisplayPath(displayPath) {\r\n    const\r\n      result = { obj: '', cnt: '', inst: '' },\r\n      ix = displayPath.indexOf(C_PERSEC),\r\n      perSec = (ix >= 0);\r\n    let objParts;\r\n\r\n    if (perSec) {\r\n      displayPath = displayPath.substr(0, ix);\r\n    }\r\n\r\n    if (![\r\n          { fmt: new RegExp('(.+)\\\\((.+)\\\\)\\\\\\\\(.+)'), parts: ['obj', 'inst', 'cnt'] }, // obj(inst)\\cnt\r\n          { fmt: new RegExp('(.+)\\\\((.+)\\\\)'), parts: ['obj', 'inst'] }, // obj(inst)\r\n          { fmt: new RegExp('(.+)\\\\\\\\(.+)'), parts: ['obj', 'cnt'] } // obj\\cnt\r\n        ].some((s) => {                             //eslint-disable-line\r\n          const parts = displayPath.match(s.fmt);\r\n          if (parts != null) {\r\n            s.parts.forEach((p, i) => {\r\n              result[p] = parts[i + 1];\r\n            });\r\n            return true;\r\n          }\r\n          return false;\r\n        })) {\r\n      // formats do not match\r\n      result.obj = displayPath;\r\n    }\r\n    // Fix SNMP column path\r\n    if (result.cnt === '' && result.obj !== '') {\r\n      if (result.obj.match('^[0-9\\\\.]+(\\\\.[0-9]+)$')) {\r\n        result.cnt = '';\r\n        if (result.inst !== '') {\r\n          result.obj = `${result.obj}.${result.inst}`;\r\n          result.inst = '';\r\n        }\r\n      } else if (result.obj.indexOf('.') >= 0) {\r\n        objParts = result.obj.split('.');\r\n        result.cnt = objParts[1];\r\n        result.obj = objParts[0];\r\n      } else {\r\n        result.cnt = result.obj;\r\n        result.obj = '';\r\n      }\r\n    }\r\n    result.perSec = perSec;\r\n    if (perSec) {\r\n      result.cnt += C_PERSEC;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function removePerSec(displayName) {\r\n    const ix = displayName.indexOf(C_PERSEC);\r\n    // todo: check if ix == displayName.length - C_PERSEC.length\r\n    return displayName.substr(0, ix);\r\n  }\r\n\r\n  function encodeDisplayPath(parts, withPerSec) {\r\n    let\r\n      result = parts.obj,\r\n      ix;\r\n    withPerSec = (withPerSec == null) ? true : withPerSec;\r\n\r\n    if (parts.inst !== '' && parts.inst != null) {\r\n      result = `${parts.obj}(${parts.inst})`;\r\n    }\r\n\r\n    if (parts.cnt !== '' && parts.cnt != null) {\r\n      if (!withPerSec && parts.perSec) { // remove /sec from counter name\r\n        ix = parts.cnt.indexOf(C_PERSEC);\r\n        result = `${result}\\\\${parts.cnt.substr(0, ix)}`;\r\n      } else {\r\n        result = `${result}\\\\${parts.cnt}`;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function counterToString(counterPath) {\r\n    const decodedCounter = decodePath(counterPath);\r\n    return encodeDisplayPath(decodedCounter, true);\r\n  }\r\n\r\n  function makeShortPath(object, counter, instance) {\r\n    if (instance === '') {\r\n      return object + CNT_SEPARATOR + counter;\r\n    }\r\n    return object + CNT_SEPARATOR + counter + CNT_SEPARATOR + instance;\r\n  }\r\n\r\n  function getSNMPDisplayPath(counterPath, shortPath, showPerSecondValue) {\r\n    const snmpPath = parseSNMPPath(counterPath);\r\n    let\r\n      oidPath,\r\n      displayPath = Promise.resolve(null);\r\n\r\n    if (snmpPath.type === counterConsts.CNT_TYPE.cstXML) {\r\n      displayPath = Promise.resolve(counterToString(snmpPath.value));\r\n    } else if (snmpPath.type === counterConsts.CNT_TYPE.cstMIB) {\r\n      oidPath = parseOIDPath(counterPath);\r\n      if (shortPath === true) {\r\n        displayPath = getShortOidPath(oidPath.objOID);\r\n      } else {\r\n        displayPath = getFullOidPath(oidPath.objOID);\r\n      }\r\n\r\n      return displayPath\r\n        .then((resolvedPath) => {\r\n          if ((resolvedPath == null) || (resolvedPath === '')) {\r\n            resolvedPath = oidPath.objOID;\r\n          }\r\n          if (oidPath.inst === '0') {\r\n            oidPath.inst = '';\r\n          }\r\n\r\n          resolvedPath = counterToString(makeShortPath(resolvedPath, '', oidPath.inst));\r\n\r\n          if ((showPerSecondValue === true) && (oidPath.isPerSec === true)) {\r\n            resolvedPath += C_PERSEC;\r\n          }\r\n          return resolvedPath;\r\n        });\r\n    }\r\n\r\n    return displayPath;\r\n  }\r\n\r\n  function counterPathToDisplayStr(counterPath, shortPath, showPerSecValue) {\r\n    const pathType = getCounterPathType(counterPath);\r\n\r\n    if ((pathType === counterConsts.CNT_TYPE.cstXML) || (pathType === counterConsts.CNT_TYPE.cstMIB)) {\r\n      return getSNMPDisplayPath(counterPath, shortPath, showPerSecValue);\r\n    }\r\n    return Promise.resolve(counterToString(counterPath));\r\n  }\r\n\r\n  function isKnownMillisecondCounter(cnt) {\r\n    return knownMSCounters.indexOf(cnt.toLowerCase()) >= 0;\r\n  }\r\n\r\n  /**\r\n   * isMillisecondsCounter(\r\n   * @param counter\r\n   * @returns {boolean}\r\n   */\r\n  function isMillisecondsCounter(counter) {\r\n    const c = decodePath(counter);\r\n    return ((c.cnt === cnRTT) || (c.cnt === cnSCT) ||\r\n            (c.cnt.toUpperCase().indexOf('MILLISECOND') >= 0) || isKnownMillisecondCounter(c.cnt));\r\n  }\r\n\r\n  function contains(cnt, substr) {\r\n    return cnt.indexOf(substr) >= 0;\r\n  }\r\n\r\n  /**\r\n   * isBytesCounter\r\n   * @param displayName\r\n   * @returns {null|''|'M'|'K'}\r\n   */\r\n  function isBytesCounter(displayName) {\r\n    const cnt = displayName.toLowerCase();\r\n    let result = '';\r\n\r\n    if (contains(cnt, resources.metrics.bytes) || contains(cnt, resources.metrics.memory) || contains(cnt, 'octet')) {\r\n      if (contains(cnt, resources.metrics.mbytes) || contains(cnt, 'mega')) {\r\n        result = 'M';\r\n      } else if (contains(cnt, resources.metrics.kbytes) || contains(cnt, 'kilo')) {\r\n        result = 'K';\r\n      }\r\n      return result;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  function getValueFormatting(value, base1, base, units = ['K', 'M', 'G']) {\r\n    let range = '';\r\n    if (value >= 1 * base1 && value < base1 * base) {\r\n      value /= base1;\r\n      range = units[0];\r\n    } else if (value >= base1 * base && value < base1 * base * base) {\r\n      value = value / base1 / base;\r\n      range = units[1];\r\n    } else if (value >= base1 * base * base) {\r\n      value = value / base1 / base / base;\r\n      range = units[2];\r\n    }\r\n    return {\r\n      value,\r\n      units: range\r\n    };\r\n  }\r\n\r\n  function getValueRange(value, kilo) {\r\n    return getValueFormatting(value, kilo, kilo);\r\n  }\r\n\r\n  function getTimeRange(value) {\r\n    return getValueFormatting(value, 1000, 60, ['sec', 'min', 'hrs']);\r\n  }\r\n\r\n  return {\r\n    unitsToMetric: (units, counterName, counterDisplayName) => {\r\n      if (units === 'bytestobps') {\r\n        return 'bps';\r\n      } else if (units === 'percentage') {\r\n        return '%';\r\n      } else if (units === 'bytesps') {\r\n        return 'Bps';\r\n      } else if (units === 'bytes') {\r\n        return 'bytes';\r\n      }\r\n      return this.getMetric(counterName, counterDisplayName);\r\n    },\r\n\r\n    /**\r\n     * Get Metric for Counter\r\n     * @param counterPath\r\n     * @param displayName\r\n     * @returns {*}\r\n     */\r\n    getMetric: (counterPath, displayName) => {\r\n      let multiplier;\r\n      if (contains(displayName, '%')) {\r\n        return counterTypes.percentage;\r\n      } else if (!isMillisecondsCounter(counterPath)) {\r\n        multiplier = isBytesCounter(displayName);\r\n        if (multiplier !== null) {\r\n          if (multiplier !== '') {\r\n            multiplier = `'#${multiplier}`;\r\n          }\r\n          if (contains(displayName, C_PERSEC) || contains(displayName, 'per sec.')) { // ESX counters are \"per sec.\"\r\n            return counterTypes.bytesBitsPS + multiplier;\r\n          }\r\n          return counterTypes.bytes + multiplier;\r\n        }\r\n        return '';\r\n      }\r\n      return counterTypes.milliseconds;\r\n    },\r\n\r\n    getDisplayValue: (value, metric) => {\r\n      const\r\n        mparts = metric.split('#'),\r\n        m = mparts[0],\r\n        multiplier = mparts.length > 1 ? mparts[1] : '',\r\n        isBPS = (m === counterTypes.bytesBitsPS),\r\n        isBytes = (m === counterTypes.bytes) || isBPS || (m === counterTypes.bytesBps),\r\n        isMS = (m === counterTypes.milliseconds),\r\n        isNoUnits = (m === '');\r\n      let v;\r\n\r\n      if (value == null || isNaN(value)) {\r\n        return { value, units: '' };\r\n      } else {                                            //eslint-disable-line\r\n        if (isBPS) {\r\n          value *= 8;\r\n        }\r\n        if (multiplier !== '') {\r\n          return {\r\n            value: Math.round(value * 100) / 100,\r\n            units: multiplier + (isBytes ? 'B' : '')\r\n          };\r\n        }\r\n        if (isBytes) {\r\n          v = getValueRange(value, 1024);\r\n          if (m === counterTypes.bytes) {\r\n            v.units += 'B';\r\n          } else {\r\n            v.units += m;\r\n          }\r\n        } else if (isNoUnits) {\r\n          v = getValueRange(value, 1000);\r\n        } else if (isMS) {\r\n          v = getTimeRange(value);\r\n          if (v.units === '') {\r\n            v.units = counterTypes.milliseconds;\r\n          }\r\n        } else {\r\n          v = {\r\n            value,\r\n            units: m\r\n          };\r\n        }\r\n        return {\r\n          value: v.value,\r\n          units: v.units\r\n        };\r\n      }\r\n    },\r\n\r\n    isOid,\r\n    isMIBCnt,\r\n    counterPathObject,\r\n    stringToCntType,\r\n    getCounterPathType,\r\n    removeCounterPathType,\r\n    removePerSecond,\r\n    parseSNMPPath,\r\n    parseOIDPath,\r\n    parseXMLPath,\r\n    parseCounterPath,\r\n    getShortOidPath,\r\n    getFullOidPath,\r\n    decodePath,\r\n    encodePath,\r\n    addInstance: (path, inst) => {\r\n      if (inst !== '') {\r\n        return path + CNT_SEPARATOR + inst;\r\n      }\r\n      return path;\r\n    },\r\n    decodeDisplayPath,\r\n    encodeDisplayPath,\r\n    removePerSec,\r\n    getSNMPDisplayPath,\r\n    counterPathToDisplayStr\r\n  };\r\n}\r\n\r\nexport {\r\n  NETCRUNCH_COUNTER_CONST,\r\n  NETCRUNCH_COUNTER_TYPES,\r\n  NetCrunchCounters\r\n};\r\n"]}